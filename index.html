<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="GB alpine skiing seed list statistical analysis">
    <meta name="author" content="Calum Shepherd">

    <!-- Bootstrap 5 CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <!-- D3.js v7 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <title>Ski Seeding</title>
</head>

<body>
    <div class="container">
        <div class="py-3 border-bottom mb-3">
            <h1>Seed Points Analysis</h1>
        </div>

        <div class="card shadow">
            <div class="card-body">
                <div id="vis"></div>
            </div>
        </div>
    </div>

    <script>
    /*
     * Bubble chart function makes use of Jane Pong's snippets
     * Source: https://bl.ocks.org/officeofjane/a70f4b44013d06b9c0a973f163d8ab7a
     */

    /**
     * Instantiate new bubble chart given a DOM element to display it in and a dataset to visualise
     * @author Jane Pong (adapted by Calum Shepherd)
     */
    function bubbleChart()
    {
        const width = 800;
        const height = 500;

        // location to centre the bubbles
        const centre = { x: width/2, y: height/2 };

        // strength to apply to the position forces
        const forceStrength = 0.05;

        // these will be set in createNodes and chart functions
        let svg = null;
        let bubbles = null;
        let labels = null;
        let nodes = [];

        /**
         * Charge is dependent on size of the bubble, so bigger towards the middle
         * @param d Data point
         * @returns Function to set charge
         */
        function charge(d)
        {
            return Math.pow(d.radius, 2.0) * 0.01
        }

        // create a force simulation and add forces to it
        const simulation = d3.forceSimulation()
            .force('charge', d3.forceManyBody().strength(charge))
            // .force('center', d3.forceCenter(centre.x, centre.y))
            .force('x', d3.forceX().strength(forceStrength).x(centre.x))
            .force('y', d3.forceY().strength(forceStrength).y(centre.y))
            .force('collision', d3.forceCollide().radius(d => d.radius + 1));

        // force simulation starts up automatically, which we don't want as there aren't any nodes yet
        simulation.stop();

        // set up colour scale
        const fillColour = d3.scaleOrdinal()
            .domain(["10", "20", "30", "50", "100"])
            .range(["#0074D9", "#7FDBFF", "#39CCCC", "#3D9970", "#AAAAAA"]);

        /**
         * Takes raw data from csv and converts it into an array of node objects
         *
         * @param rawData Array of data objects, read in with d3.csv()
         * @returns New node array, with a node for each element in the rawData input
         */
        function createNodes(rawData)
        {
            // group data by club
            const processed = d3.group(rawData, d => d.Club);

            // use max size in the data as the max in the scale's domain
            // note we have to ensure that size is a number
            const maxSize = d3.max(processed, d => +d[1].length);

            // size bubbles based on area
            const radiusScale = d3.scaleSqrt()
                .domain([0, maxSize])
                .range([0, 120]);

            // use map() to convert raw data into node data
            const myNodes = d3.map(processed, d => ({
                // remove original data here
                //...d,
                id: d[0],
                groupid: 1,
                radius: radiusScale(+d[1].length),
                size: +d[1].length,
                x: Math.random() * 900,
                y: Math.random() * 800
            })).filter(function (d)
            {
                return d.id !== "" && d.size >= 10;
            });

            return myNodes;
        }

        /*
         * Main entry point to bubble chart, returned by parent closure
         * Prepares rawData for visualisation and adds an svg element to the provided
         * selector and starts the visualisation process
         */
        let chart = function chart(selector, rawData)
        {
            // convert raw data into nodes data
            nodes = createNodes(rawData)

            // create svg element inside provided selector
            svg = d3.select(selector)
                .append('svg')
                .attr('width', width)
                .attr('height', height)

            // bind nodes data to circle elements
            const elements = svg.selectAll('.bubble')
                .data(nodes, d => d.id)
                .enter()
                .append('g')

            bubbles = elements
                .append('circle')
                .classed('bubble', true)
                .attr('r', d => d.size)
                .attr('fill', d => fillColour(d.size))

            // labels
            labels = elements
                .append('text')
                .attr('dy', '.3em')
                .style('text-anchor', 'middle')
                .style('font-size', 10)
                .text(d => d.id)

            // set simulation's nodes to our newly created nodes array
            // simulation starts running automatically once nodes are set
            simulation.nodes(nodes)
                .on('tick', ticked)
                .restart();
        }

        /**
         * Called after every tick of the force simulation
         * Here we do the actual repositioning of the circles based on
         * current x and y value of their bound node data
         */
        function ticked() {
            bubbles
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)

            labels
                .attr('x', d => d.x)
                .attr('y', d => d.y)
        }

        // return chart function from closure
        return chart;
    }

    // new bubble chart instance
    let myBubbleChart = bubbleChart();

    /**
     * Callback for when promise is resolved and data is loaded from csv.
     * Calls bubble chart function to display inside #vis div.
     */
    function display(data)
    {
        myBubbleChart('#vis', data);
    }

    // load data
    d3.csv('https://raw.githubusercontent.com/cws3-f20dv/lab4/main/data/BASS2021-8.csv').then(display);
    </script>
</body>
</html>
